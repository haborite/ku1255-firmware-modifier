#!/usr/bin/env python3
"""
Usage:
    python apply_diff.py Origin.asm diff.json comments.txt Modified.asm

- Extract only the code part from Origin.asm.
- Apply diff.json (a sequence of operations) to rebuild the code part of B.
- Combine the regenerated B code with comments.txt and output Modified.asm.

Prerequisites:
    diff.json and comments.txt must be generated by make_diff.py.
"""

import sys
import json
from typing import List, Tuple


def split_code_comment(line: str) -> Tuple[str, str]:
    """Split a line into (code, comment). For reading A."""
    line = line.rstrip("\n")
    idx = line.find(";")
    if idx == -1:
        return line, ""
    return line[:idx], line[idx:]


def read_codes(path: str) -> List[str]:
    """Return only the code part (per line, no newline) from Origin.asm."""
    codes: List[str] = []
    with open(path, encoding="utf-8") as f:
        for raw in f:
            code, _ = split_code_comment(raw)
            codes.append(code)
    return codes


def build_b_codes(a_codes: List[str], ops: List[dict]) -> List[str]:
    """Apply the operation list to A’s code to generate B’s code."""
    b_codes: List[str] = []

    for op in ops:
        kind = op.get("op")
        if kind == "copy":
            line_a = op.get("from")
            if not isinstance(line_a, int) or line_a <= 0:
                raise ValueError(f"Invalid 'from' in op: {op}")
            idx = line_a - 1
            if idx < 0 or idx >= len(a_codes):
                raise IndexError(f"'from' line {line_a} is out of range for A")
            b_codes.append(a_codes[idx])

        elif kind == "insert":
            code = op.get("code", "")
            if not isinstance(code, str):
                raise ValueError(f"Invalid 'code' in op: {op}")
            b_codes.append(code)

        else:
            raise ValueError(f"Unknown op type: {kind}")

    return b_codes


def main() -> None:
    if len(sys.argv) != 5:
        print(
            "Usage: python apply_json_diff_ops.py "
            "Origin.asm diff.json comments.txt Modified.asm",
            file=sys.stderr,
        )
        sys.exit(1)

    a_path, diff_path, comments_path, b_path = sys.argv[1:5]

    # Extract code part from A
    a_codes = read_codes(a_path)

    # Load operation list JSON
    with open(diff_path, encoding="utf-8") as f_diff:
        diff_obj = json.load(f_diff)
    ops = diff_obj.get("ops", [])
    if not isinstance(ops, list):
        raise ValueError("diff.json does not contain a list under 'ops'")

    # Build B code by applying operation list
    b_codes = build_b_codes(a_codes, ops)

    # Read comments file
    with open(comments_path, encoding="utf-8") as f_com:
        comments = [ln.rstrip("\n") for ln in f_com]

    if len(b_codes) != len(comments):
        raise ValueError(
            f"Number of code lines after ops ({len(b_codes)}) "
            f"!= number of comment lines ({len(comments)})"
        )

    # Combine code + comment and output Modified.asm
    with open(b_path, "w", encoding="utf-8") as f_out:
        for code, comment in zip(b_codes, comments):
            f_out.write(code + comment + "\n")


if __name__ == "__main__":
    main()
